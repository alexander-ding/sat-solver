\documentclass[10pt]{article}
\usepackage[margin=0.5in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{listings}
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{commentsColor}\textit,    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=tb,	                   	   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{keywordsColor}\bfseries,       % keyword style
  language=Python,                 % the language of the code (can be overrided per snippet)
  otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{commentsColor}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{stringColor}, % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                  % show the filename of files included with \lstinputlisting; also try caption instead of title
  columns=fixed                    % Using fixed column width (for e.g. nice alignment)
}

\usepackage{xcolor}
\definecolor{commentsColor}{rgb}{0.497495, 0.497587, 0.497464}
\definecolor{keywordsColor}{rgb}{0.000000, 0.000000, 0.635294}
\definecolor{stringColor}{rgb}{0.558215, 0.000000, 0.135316}
\hypersetup{
    colorlinks=true,
}

\newtheorem{thm}{Theorem}[part]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{claim}[thm]{Claim}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{conj}[thm]{Conjecture}



\theoremstyle{definition} % text is not in italics
\newtheorem{ex}[thm]{Example}
\newtheorem{defn}[thm]{Definition}


\newcommand{\Af}{\mathbb{A}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\FF}{\mathbb{F}}
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}
\newcommand{\cH}{\mathcal{H}}
\newcommand{\cI}{\mathcal{I}}
\newcommand{\cJ}{\mathcal{J}}
\newcommand{\cK}{\mathcal{K}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\cV}{\mathcal{V}}
\newcommand{\cW}{\mathcal{W}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cY}{\mathcal{Y}}
\newcommand{\cZ}{\mathcal{Z}}
\newcommand{\SV}{\mathrm{SV}}
\newcommand{\SYT}{\mathrm{SYT}}
\newcommand{\ra}{\rightarrow}
\newcommand{\comment}[1]{}
\newcommand{\on}{\operatorname}
\newcommand{\Gr}{\operatorname{Gr}}
\newcommand{\Spec}{\operatorname{Spec}}
\newcommand{\Mor}{\mathrm{Mor}}
\newcommand{\GL}{\mathrm{GL}}
\newcommand{\Fun}{\on{Fun}}
\newcommand{\col}{\colon}
\newcommand{\eps}{\varepsilon}
\newcommand{\op}{\mathrm{op}}
\newcommand{\mc}{\mathcal}
\newcommand{\ov}{\overline}
\newcommand{\wt}{\widetilde}
\newcommand{\und}{\underline}
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}

\newcommand{\bs}{\boldsymbol}
\newcommand{\ul}{\underline}
\newcommand{\st}{\scriptstyle}
\newcommand{\noi}{\noindent}
\newcommand{\bu}{\bullet}
\newcommand{\Ra}{\Rightarrow}

\newcommand{\End}{\on{End}}
\newcommand{\Set}{\bf Set}
\newcommand{\Vect}{{\bf Vect}}
\newcommand{\Conf}{\mathrm{Conf}}
\newcommand{\Frac}{\on{Frac}}
\newcommand{\ev}{\mathrm{ev}}
\newcommand{\Id}{\on{Id}}
\newcommand{\im}{\on{im}}
\newcommand{\coim}{\on{coim}}
\newcommand{\cok}{\on{cok}}
\newcommand{\Hom}{\on{Hom}}
\newcommand{\Jac}{\on{Jac}}
\newcommand{\Nil}{\on{Nil}}
\newcommand{\Rmod}{R\text{-mod}}
\newcommand{\xmod}[1]{#1\text{-mod}}
\newcommand{\Smod}{S\text{-mod}}
\newcommand{\Amod}{A\text{-mod}}
\newcommand{\Bmod}{B\text{-mod}}
\newcommand{\tand}{\ \text{and}\ }
\newcommand{\tor}{\ \text{or}\ }
\newcommand{\Ann}{\on{Ann}}
\newcommand{\Tor}{\mathrm{Tor}}
\newcommand{\limit}[1]{\underset{\leftarrow #1}{\mathrm{lim}}\,}
\newcommand{\colimit}[1]{\underset{\rightarrow #1}{\mathrm{lim}}\,}
\newcommand{\hide}[1]{}
\newcommand{\myfill}{

\vspace{1cm}

}
\newcommand{\xra}{\xrightarrow}
\newcommand{\lra}{\longrightarrow}
\DeclareMathOperator{\cov}{Cov}
\DeclareMathOperator{\mse}{MSE}

\begin{document}
\begin{center}
  \Large{\sc{CSCI 2951O: Project Report}} \\
  \normalsize{\sc{February 25, 2022}} \\
  \normalsize{Alex Ding (CS: ading13. Screen: evian)} \\
  \vspace{5pt}
\end{center}

\section{Design}

My initial implementations were in Python, a terrible choice in hindsight. Next time, I'll probably start with C++ or Julia. I started with the DPLL algorithm shown on the slides (with both pure literal elimination and BCP), but the performance was terrible, only being able to solve the toy instances on time. After consulting relevant literatures, I decided to get rid of pure literal elimination (which is expensive to compute in general) and implemented 2 watched literals, relying only on branching and BCP. Afterwards, I extracted the original pure literal elimination and BCP routines as a preprocessing technique to simplify the instance before the decide-BCP-repeat loop that uses watched literals. This setup was able to solve a good number of SAT instances in 2-3 minutes. A quick but effective improvement was to implement the Jeroslow-Wang heuristic for variable selection, which helped runtime tremendously. At this point, the model was struggling with UNSAT instances, and I was out of ideas on how to improve my code without CDCL, which is exactly what I implemented next. This was very tricky to get right, and I had to read up a lot. I ended up going with the same implementation Chaff proposed, terminating clause expansion at the first UIP and flipping the assignment after nonchronological backtracking. My code was performant at this point, but after profiling, I realized that Jeroslow-Wang was the bottleneck, as the number of clauses grows quickly. I then implemented VSIDS (EVSIDS specifically), which showed mixed results (I realized later that there was a bug in my code which caused EVSIDS to not work correctly). I also implemented random restarts with a Luby sequence, which also didn't help things too much. 

At this point, I decided to move to a faster language. I chose Julia for its syntactic similarity with Python, which helped with the translation, but the fact that it's compiled and has performance comparable to C guaranteed a fast runtime. I never used the language before, so this was a really fun (and time-consuming) learning experience, but this cut the time spent on most instances by $5$ times. I spent a lot of time optimizing the various parts of the code to shave some more time off. The solver can solve all except $5$ instances in time, all of which are SAT. I have some suspicion that something is not right with my SAT termination conditions, but I can't figure it out for the life of me, and at this point I've already way too many hours on the project in $1$ week, so I'm calling it quits.\footnote{This was a wild experience. My life became SAT solvers, and I spent most of my waking hours thinking about it. It's somewhat discouraging, though, that my final solver, with all the bells and whistles, can't even solve a third of the test cases :(, but still I definitely learned a lot. Anyways, I'm definitely going to partner up next time to not go through this again. }

\section{Failed Attempts}

I observed that the number of clauses quickly balloons out of control in the SAT cases it can't solve, and this slows the solver down a lot. A lot of these learned clauses are super long and kind of useless, so I tried to implement an on-line clause deletion scheme, but when I delete an old clause it breaks the implication graph (e.g., some variable assignment is caused by the deleted clause; what should I do now?). I don't really have time to investigate this further, but something along this line looks promising. 

I also pursued the idea that my code doesn't work on non-trivial satisfiable instances further. I found a bunch of satisfiable DIMACS files online, but my solver performed well on all of them, so I'm not sure what's going on with the satisfiable instances in the test suite. I noticed that they're all instances with very few variables (50 or 75) and relatively many clauses (1000-2000), so something more on a pure DPLL-based solution would work a lot better? 

\section{Total Time Spent}
Around 60 hours. Lost a bit of my sanity, but it was very rewarding as well. Plus, I would love to see what is wrong with my SAT solver for these SAT instances. If someone can take a look that'd be fantastic. 

\end{document}